const WhatsAppChecker = require('./WhatsAppChecker');
const path = require('path');

class WhatsAppManager {
  constructor(database) {
    this.db = database;
    this.instances = new Map(); // instanceId -> WhatsAppChecker
  }

  async createInstance(userId, instanceName) {
    try {
      const authPath = `auth/user_${userId}_${Date.now()}`;
      
      // Salvar no banco
      const result = await this.db.query(
        'INSERT INTO whatsapp_instances (user_id, name, auth_path, status) VALUES (?, ?, ?, ?)',
        [userId, instanceName, authPath, 'disconnected']
      );
      
      const instanceId = result.insertId;
      
      // Criar checker
      const checker = new WhatsAppChecker(authPath);
      this.instances.set(instanceId, checker);
      
      // Configurar eventos
      this.setupInstanceEvents(instanceId, checker);
      
      return { instanceId, checker };
    } catch (error) {
      console.error('‚ùå Erro ao criar inst√¢ncia:', error);
      throw error;
    }
  }

  setupInstanceEvents(instanceId, checker, callbacks = {}) {
    checker.on('ready', async () => {
      await this.updateInstanceStatus(instanceId, 'connected');
      
      // Fazer backup da sess√£o quando conectar
      setTimeout(() => {
        this.backupSessionToDatabase(instanceId);
      }, 5000); // Aguardar 5s para sess√£o estabilizar
      
      if (callbacks.onConnected) {
        callbacks.onConnected();
      }
    });

    checker.on('disconnected', async () => {
      await this.updateInstanceStatus(instanceId, 'disconnected');
      if (callbacks.onDisconnected) {
        callbacks.onDisconnected();
      }
    });

    checker.on('qr', (qr) => {
      console.log(`üì± QR Code gerado para inst√¢ncia ${instanceId}`);
      if (callbacks.onQRCode) {
        callbacks.onQRCode(qr);
      }
    });
  }

  async updateInstanceStatus(instanceId, status) {
    try {
      await this.db.query(
        'UPDATE whatsapp_instances SET status = ? WHERE id = ?',
        [status, instanceId]
      );
    } catch (error) {
      console.error('‚ùå Erro ao atualizar status:', error);
    }
  }

  async getInstance(instanceId) {
    if (this.instances.has(instanceId)) {
      return this.instances.get(instanceId);
    }

    // Carregar do banco se n√£o estiver em mem√≥ria
    const results = await this.db.query(
      'SELECT * FROM whatsapp_instances WHERE id = ?',
      [instanceId]
    );

    if (results.length === 0) {
      throw new Error('Inst√¢ncia n√£o encontrada');
    }

    const instance = results[0];
    const checker = new WhatsAppChecker(instance.auth_path);
    this.instances.set(instanceId, checker);
    this.setupInstanceEvents(instanceId, checker);

    return checker;
  }

  async getUserInstances(userId) {
    const results = await this.db.query(
      'SELECT * FROM whatsapp_instances WHERE user_id = ? ORDER BY created_at DESC',
      [userId]
    );
    
    // Log para debug
    console.log(`üì± Inst√¢ncias encontradas para usu√°rio ${userId}:`, results.length);
    
    // Atualizar status real das inst√¢ncias
    const instancesWithRealStatus = results.map(instance => {
      const realStatus = this.getRealInstanceStatus(instance.id);
      
      // Se o status real for diferente do banco, atualizar
      if (realStatus !== instance.status) {
        this.updateInstanceStatus(instance.id, realStatus);
        instance.status = realStatus;
      }
      
      console.log(`  - ID: ${instance.id}, Nome: ${instance.name}, Status: ${instance.status}`);
      return instance;
    });
    
    return instancesWithRealStatus;
  }

  // M√©todo para obter status real da inst√¢ncia
  getRealInstanceStatus(instanceId) {
    if (this.instances.has(instanceId)) {
      const checker = this.instances.get(instanceId);
      if (checker.isConnected()) {
        return 'connected';
      } else if (checker.isConnecting) {
        return 'connecting';
      } else {
        return 'disconnected';
      }
    }
    return 'disconnected';
  }

  async deleteInstance(instanceId, userId) {
    try {
      // Verificar se pertence ao usu√°rio
      const results = await this.db.query(
        'SELECT * FROM whatsapp_instances WHERE id = ? AND user_id = ?',
        [instanceId, userId]
      );

      if (results.length === 0) {
        throw new Error('Inst√¢ncia n√£o encontrada ou n√£o autorizada');
      }

      console.log(`üóëÔ∏è Removendo inst√¢ncia ${instanceId}...`);

      // Desconectar e parar tentativas de reconex√£o se estiver ativo
      if (this.instances.has(instanceId)) {
        const checker = this.instances.get(instanceId);
        console.log(`üõë Parando inst√¢ncia ${instanceId}...`);
        
        // Parar tentativas de reconex√£o
        checker.stopReconnecting();
        
        // Desconectar
        await checker.disconnect();
        
        // Remover do mapa
        this.instances.delete(instanceId);
        console.log(`‚úÖ Inst√¢ncia ${instanceId} removida do manager`);
      }

      // Remover do banco
      await this.db.query('DELETE FROM whatsapp_instances WHERE id = ?', [instanceId]);
      console.log(`‚úÖ Inst√¢ncia ${instanceId} removida do banco`);

      // Remover pasta de autentica√ß√£o
      const fs = require('fs');
      const authPath = path.join(__dirname, '../../', results[0].auth_path);
      if (fs.existsSync(authPath)) {
        fs.rmSync(authPath, { recursive: true, force: true });
        console.log(`‚úÖ Pasta de auth removida: ${authPath}`);
      }

      return true;
    } catch (error) {
      console.error('‚ùå Erro ao deletar inst√¢ncia:', error);
      throw error;
    }
  }

  async connectInstance(instanceId, callbacks = {}) {
    try {
      const checker = await this.getInstance(instanceId);
      
      // Verificar se j√° est√° conectado
      if (checker.isConnected()) {
        console.log(`‚úÖ Inst√¢ncia ${instanceId} j√° est√° conectada`);
        return checker;
      }
      
      // Verificar se j√° est√° tentando conectar
      if (checker.isConnecting) {
        console.log(`üîÑ Inst√¢ncia ${instanceId} j√° est√° tentando conectar`);
        return checker;
      }
      
      // Configurar eventos tempor√°rios apenas para este connect
      const tempEvents = {};
      
      if (callbacks.onQRCode) {
        tempEvents.onQR = (qr) => callbacks.onQRCode(qr);
        checker.on('qr', tempEvents.onQR);
      }
      
      if (callbacks.onConnected) {
        tempEvents.onReady = () => {
          callbacks.onConnected();
          // Limpar eventos tempor√°rios
          if (tempEvents.onQR) checker.off('qr', tempEvents.onQR);
          if (tempEvents.onReady) checker.off('ready', tempEvents.onReady);
          if (tempEvents.onDisconnected) checker.off('disconnected', tempEvents.onDisconnected);
        };
        checker.on('ready', tempEvents.onReady);
      }
      
      if (callbacks.onDisconnected) {
        tempEvents.onDisconnected = () => {
          callbacks.onDisconnected();
          // Limpar eventos tempor√°rios
          if (tempEvents.onQR) checker.off('qr', tempEvents.onQR);
          if (tempEvents.onReady) checker.off('ready', tempEvents.onReady);
          if (tempEvents.onDisconnected) checker.off('disconnected', tempEvents.onDisconnected);
        };
        checker.on('disconnected', tempEvents.onDisconnected);
      }
      
      await checker.connect();
      
      return checker;
    } catch (error) {
      console.error('‚ùå Erro ao conectar inst√¢ncia:', error);
      throw error;
    }
  }

  async disconnectInstance(instanceId) {
    if (this.instances.has(instanceId)) {
      const checker = this.instances.get(instanceId);
      console.log(`üõë Desconectando inst√¢ncia ${instanceId}...`);
      await checker.disconnect();
      await this.updateInstanceStatus(instanceId, 'disconnected');
      
      // Remover da mem√≥ria para parar completamente
      this.instances.delete(instanceId);
      console.log(`üõë Inst√¢ncia ${instanceId} removida da mem√≥ria`);
    }
  }

  async getUserInstance(userId, instanceId) {
    const results = await this.db.query(
      'SELECT * FROM whatsapp_instances WHERE id = ? AND user_id = ?',
      [instanceId, userId]
    );
    
    return results.length > 0 ? results[0] : null;
  }

  async getInstanceByToken(tokenId) {
    try {
      const result = await this.db.query(
        'SELECT whatsapp_instance_id FROM api_tokens WHERE id = ?',
        [tokenId]
      );
      
      if (result.length === 0 || !result[0].whatsapp_instance_id) {
        return null;
      }
      
      const instanceId = result[0].whatsapp_instance_id;
      const checker = await this.getInstance(instanceId);
      
      // Retornar objeto com checker e id da inst√¢ncia
      return {
        ...checker,
        id: instanceId,
        isConnected: () => checker.isConnected(),
        getConnectionStatus: () => checker.getConnectionStatus()
      };
    } catch (error) {
      console.error('‚ùå Erro ao buscar inst√¢ncia por token:', error);
      return null;
    }
  }
  
  getAllInstances() {
    return Array.from(this.instances.values());
  }

  // Inicializar todas as inst√¢ncias salvas (para uso no startup)
  async initializeAllInstances() {
    try {
      console.log('üîÑ Inicializando inst√¢ncias salvas...');
      
      // Buscar todas as inst√¢ncias do banco
      const instances = await this.db.query(
        'SELECT * FROM whatsapp_instances ORDER BY created_at DESC'
      );
      
      console.log(`üì± Encontradas ${instances.length} inst√¢ncias para inicializar`);
      
      for (const instance of instances) {
        try {
          await this.initializeInstance(instance);
        } catch (error) {
          console.error(`‚ùå Erro ao inicializar inst√¢ncia ${instance.id}:`, error.message);
        }
      }
      
      console.log('‚úÖ Inicializa√ß√£o de inst√¢ncias conclu√≠da');
    } catch (error) {
      console.error('‚ùå Erro ao inicializar inst√¢ncias:', error);
    }
  }

  // Inicializar uma inst√¢ncia espec√≠fica
  async initializeInstance(instanceData) {
    const { id, auth_path, name, user_id } = instanceData;
    
    console.log(`üîÑ Inicializando inst√¢ncia ${id} (${name}) para usu√°rio ${user_id}`);
    
    // Verificar se auth files existem
    const fs = require('fs');
    const authExists = fs.existsSync(auth_path) && 
                      fs.existsSync(`${auth_path}/creds.json`);
    
    if (!authExists) {
      console.log(`‚ö†Ô∏è  Inst√¢ncia ${id}: Auth files n√£o encontrados, tentando restaurar do banco...`);
      
      // Tentar restaurar do banco
      const restored = await this.restoreSessionFromDatabase(id, auth_path);
      
      if (!restored) {
        console.log(`‚ùå Inst√¢ncia ${id}: N√£o foi poss√≠vel restaurar, status: disconnected`);
        await this.updateInstanceStatus(id, 'disconnected');
        return;
      }
      
      console.log(`‚úÖ Inst√¢ncia ${id}: Sess√£o restaurada do banco!`);
    }
    
    // Criar WhatsAppChecker
    const checker = new WhatsAppChecker(auth_path);
    this.instances.set(id, checker);
    
    // Configurar eventos
    this.setupInstanceEvents(id, checker, {
      onConnected: () => {
        console.log(`‚úÖ Inst√¢ncia ${id} reconectada automaticamente`);
      },
      onDisconnected: () => {
        console.log(`‚ùå Inst√¢ncia ${id} desconectada`);
      }
    });
    
    // Tentar conectar automaticamente
    try {
      console.log(`üîÑ Tentando reconectar inst√¢ncia ${id}...`);
      await checker.connect();
      
      // Se conectou sem erro, marcar como connecting (vai para connected quando ready)
      await this.updateInstanceStatus(id, 'connecting');
    } catch (error) {
      console.log(`‚ö†Ô∏è  Inst√¢ncia ${id}: Falha na reconex√£o autom√°tica - ${error.message}`);
      await this.updateInstanceStatus(id, 'disconnected');
    }
  }

  // Reconectar todas as inst√¢ncias (√∫til para restart graceful)
  async reconnectAllInstances() {
    console.log('üîÑ Reconectando todas as inst√¢ncias...');
    
    for (const [instanceId, checker] of this.instances) {
      try {
        if (checker && !checker.isConnected()) {
          console.log(`üîÑ Reconectando inst√¢ncia ${instanceId}...`);
          await checker.connect();
        }
      } catch (error) {
        console.error(`‚ùå Erro ao reconectar inst√¢ncia ${instanceId}:`, error.message);
      }
    }
  }

  // Parar todas as inst√¢ncias gracefully (para shutdown)
  async disconnectAllInstances() {
    console.log('üõë Desconectando todas as inst√¢ncias...');
    
    for (const [instanceId, checker] of this.instances) {
      try {
        if (checker && checker.isConnected()) {
          console.log(`üõë Desconectando inst√¢ncia ${instanceId}...`);
          await checker.disconnect();
        }
      } catch (error) {
        console.error(`‚ùå Erro ao desconectar inst√¢ncia ${instanceId}:`, error.message);
      }
    }
    
    this.instances.clear();
  }

  // Verificar status de uma inst√¢ncia
  isInstanceConnected(instanceId) {
    const checker = this.instances.get(instanceId);
    return checker ? checker.isConnected() : false;
  }

  // Obter estat√≠sticas das inst√¢ncias
  getInstancesStats() {
    const total = this.instances.size;
    let connected = 0;
    let disconnected = 0;
    
    for (const [instanceId, checker] of this.instances) {
      if (checker.isConnected()) {
        connected++;
      } else {
        disconnected++;
      }
    }
    
    return { total, connected, disconnected };
  }
  
  // Backup da sess√£o para o banco
  async backupSessionToDatabase(instanceId) {
    try {
      const instance = this.instances.get(instanceId);
      if (!instance) return;
      
      const authPath = instance.authDir || instance.authPath;
      if (!authPath) return;
      
      const fs = require('fs');
      const path = require('path');
      
      const credsPath = path.join(authPath, 'creds.json');
      
      if (fs.existsSync(credsPath)) {
        const sessionData = fs.readFileSync(credsPath, 'utf8');
        
        await this.db.query(
          'UPDATE whatsapp_instances SET session_data = ?, session_backup_at = NOW() WHERE id = ?',
          [sessionData, instanceId]
        );
        
        console.log(`üíæ Sess√£o da inst√¢ncia ${instanceId} salva no banco`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao fazer backup da sess√£o ${instanceId}:`, error);
    }
  }
  
  // Restaurar sess√£o do banco
  async restoreSessionFromDatabase(instanceId, authPath) {
    try {
      const sessions = await this.db.query(
        'SELECT session_data FROM whatsapp_instances WHERE id = ? AND session_data IS NOT NULL',
        [instanceId]
      );
      
      if (sessions.length === 0) {
        console.log(`üì≠ Nenhum backup de sess√£o encontrado para inst√¢ncia ${instanceId}`);
        return false;
      }
      
      const sessionData = sessions[0].session_data;
      
      const fs = require('fs');
      const path = require('path');
      
      // Criar diret√≥rio se n√£o existir
      if (!fs.existsSync(authPath)) {
        fs.mkdirSync(authPath, { recursive: true });
      }
      
      const credsPath = path.join(authPath, 'creds.json');
      fs.writeFileSync(credsPath, sessionData);
      
      console.log(`üîÑ Sess√£o da inst√¢ncia ${instanceId} restaurada do banco`);
      return true;
    } catch (error) {
      console.error(`‚ùå Erro ao restaurar sess√£o ${instanceId}:`, error);
      return false;
    }
  }
}

module.exports = WhatsAppManager;
